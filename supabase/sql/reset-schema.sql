-- My complete database schema for FamilySync.
-- This script will completely reset the database, deleting any existing
-- data and structures, and then rebuild it from scratch with all the
-- necessary tables, functions, triggers, and security policies.

-- Step 1: I'm tearing down the old structure to prevent any conflicts.
-- I'll drop the tables first. Using CASCADE is a clean way to handle dependencies
-- and will also remove the RLS policies that rely on the functions below.
DROP TABLE IF EXISTS public.child_activities CASCADE;
DROP TABLE IF EXISTS public.chores CASCADE;
DROP TABLE IF EXISTS public.meal_plans CASCADE;
DROP TABLE IF EXISTS public.profiles CASCADE;
DROP TABLE IF EXISTS public.families CASCADE;

-- Now that the tables and their policies are gone, I can safely drop the functions and triggers.
DROP TRIGGER IF EXISTS create_profile_on_signup ON auth.users;
DROP FUNCTION IF EXISTS public.handle_new_user();
DROP FUNCTION IF EXISTS public.setup_family_for_new_parent();
DROP FUNCTION IF EXISTS public.current_user_family_id();


-- Step 2: Now I'll build everything back up from a clean slate.
-- I'll enable the uuid-ossp extension, which is great for generating unique IDs.
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- This is the main table for families. Each family gets one entry.
CREATE TABLE public.families (
  id          uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  family_name text NOT NULL,
  created_at  timestamptz DEFAULT now()
);

-- This table stores the profiles for every user, linking them to a family and a role.
CREATE TABLE public.profiles (
  id         uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  full_name  text NOT NULL,
  role       text NOT NULL CHECK (role in ('admin','parent','child','cook','driver')),
  family_id  uuid REFERENCES public.families(id) ON DELETE SET NULL, -- Use SET NULL so deleting a family doesn't delete the user's login
  created_at timestamptz DEFAULT now()
);

-- This table will hold all the meal plans generated by the AI.
CREATE TABLE public.meal_plans (
  id                  uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id             uuid REFERENCES auth.users(id) ON DELETE SET NULL, -- The user who created it
  family_id           uuid NOT NULL REFERENCES public.families(id) ON DELETE CASCADE,
  meals_json          jsonb NOT NULL,
  week_start          date NOT NULL,
  assigned_to_cook_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL, -- The cook assigned to this plan
  created_at          timestamptz DEFAULT now()
);

-- This is where I'll track all the chores.
CREATE TABLE public.chores (
  id                   uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  family_id            uuid NOT NULL REFERENCES public.families(id) ON DELETE CASCADE,
  assigned_to_child_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  task                 text NOT NULL,
  due_date             date,
  status               text NOT NULL DEFAULT 'pending',
  reward_points        integer DEFAULT 10,
  created_at           timestamptz DEFAULT now()
);

-- And finally, the table for all child activities.
CREATE TABLE public.child_activities (
  id                    uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
  family_id             uuid NOT NULL REFERENCES public.families(id) ON DELETE CASCADE,
  child_id              uuid NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  title                 text NOT NULL,
  date                  date NOT NULL,
  time                  time NOT NULL,
  location              text,
  assigned_to_driver_id uuid REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at            timestamptz DEFAULT now()
);


-- Step 3: Now I'll set up the functions and triggers that automate the app.
-- This is a helper function to easily get the family ID of the currently logged-in user.
CREATE OR REPLACE FUNCTION public.current_user_family_id()
RETURNS uuid LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT family_id FROM public.profiles WHERE id = auth.uid();
$$;

-- This is the corrected function to automatically create a user profile after signup.
-- It now reliably gets the data from raw_user_meta_data.
-- It also correctly handles invited members by setting their family_id on creation.
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS trigger LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.profiles(id, full_name, role, family_id)
  VALUES (
      NEW.id,
      NEW.raw_user_meta_data->>'full_name',
      NEW.raw_user_meta_data->>'role',
      (NEW.raw_user_meta_data->>'family_id')::uuid -- This will be NULL for public signups and will be set correctly for invites.
  );
  RETURN NEW;
END;
$$;

-- And this is the trigger that calls the function above.
CREATE TRIGGER create_profile_on_signup
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- This is the new function that creates a family for a new parent user
-- the first time they log in. It's called from the React app.
CREATE OR REPLACE FUNCTION public.setup_family_for_new_parent()
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  current_user_profile public.profiles;
  new_family_id uuid;
BEGIN
  -- Find the profile for the currently authenticated user.
  SELECT * INTO current_user_profile FROM public.profiles WHERE id = auth.uid();

  -- If the user is a 'parent' and doesn't have a family yet, I'll create one.
  IF current_user_profile.role = 'parent' AND current_user_profile.family_id IS NULL THEN
    -- I'll create a new family and name it after the parent.
    INSERT INTO public.families (family_name)
    VALUES (current_user_profile.full_name || '''s Family')
    RETURNING id INTO new_family_id;

    -- Then I'll update the parent's profile to link them to the new family.
    UPDATE public.profiles
    SET family_id = new_family_id
    WHERE id = auth.uid();
  END IF;
END;
$$;


-- Step 4: Finally, I'll enable Row Level Security and define the access policies.
-- This is what keeps each family's data private to them.
ALTER TABLE public.families ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.meal_plans ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.chores ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.child_activities ENABLE ROW LEVEL SECURITY;

-- These policies ensure that users can only interact with data from their own family.
CREATE POLICY "Users can view their own family" ON public.families FOR SELECT USING (id = public.current_user_family_id());
CREATE POLICY "Parents can create a family (implicitly handled by setup_family_for_new_parent)" ON public.families FOR INSERT WITH CHECK (auth.role() = 'authenticated');

CREATE POLICY "Users can view profiles in their own family" ON public.profiles FOR SELECT USING (family_id = public.current_user_family_id());
CREATE POLICY "Users can update their own profile" ON public.profiles FOR UPDATE USING (auth.uid() = id);

CREATE POLICY "Family members can manage their own meal plans" ON public.meal_plans FOR ALL USING (family_id = public.current_user_family_id());
CREATE POLICY "Family members can manage their own chores" ON public.chores FOR ALL USING (family_id = public.current_user_family_id());
CREATE POLICY "Children can update their own assigned chores" ON public.chores FOR UPDATE USING (auth.uid() = assigned_to_child_id);
CREATE POLICY "Family members can manage their own child activities" ON public.child_activities FOR ALL USING (family_id = public.current_user_family_id());
